<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,user-scalable=no,minimum-scale=1.0,maximum-scale=1.0"
    />
    <meta
      name="description"
      content="Real-time interactive 3D graphics in your browser using the WebGL and the Three.js JavaScript library"
    />
    <meta
      name="keywords"
      content="Three.js,WebGL,JavaScript,GitHub,FOSS,3D,STEM"
    />
    <meta name="version" content="2020-05-20" />

    <title>text 3d</title>

    <style>
      /* Copyright 2020 Theo Armour. MIT License */

      :root {
        font: 100% monospace;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        overflow: hidden;
      }

      a {
        color: crimson;
        text-decoration: none;
      }
      a:hover,
      a:focus,
      a:active {
        background-color: yellow;
        color: #aaa;
        text-decoration: underline;
      }

      button {
        background-color: #ddd;
        border: none;
        border-radius: 2px;
        color: #322;
        cursor: pointer;
        padding: 3px 5px;
      }
      button:hover {
        background: #ccc;
        color: #fff;
      }

      input[type="range"] {
        -webkit-appearance: none;
        -moz-appearance: none;
        background-color: #ddd;
        border-radius: 2px;
        height: 1.7ch;
        width: 100%;
      }
      input[type="range"]::-moz-range-thumb {
        background-color: #888;
        border-radius: 2;
        width: 10px;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        background-color: #888;
        height: 18px;
        width: 10px;
      }

      .info {
        float: right;
      }

      .info:hover > .infotooltip {
        display: block;
      }

      .infotooltip {
        border: 0.8ch double #888;
        background: white;
        display: none;
        font: 100% monospace;
        font-size: 1rem;
        font-weight: normal; /* unset summary settings */
        margin-left: -28ch;
        padding: 10px;
        position: absolute;
        z-index: 1000;
      }

      .navText {
        background-color: white;
        margin: 1ch 0;
        padding: 1ch;
      }

      #navMenu {
        margin: 0 20px;
        max-width: 15rem;
        position: absolute;
      }
    </style>
  </head>

  <body>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r116/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r116/examples/js/controls/OrbitControls.js"></script>
   
    <script src="https://cdn.jsdelivr.net/npm/troika-three-utils@0.27.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/troika-worker-utils@0.27.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/troika-3d-text@0.27.0/dist/textmesh-standalone.umd.min.js"></script>

    <nav id="navMenu">
      <header id="hdrTitle">
        <h2>
          <a href="" title="Click to reload this page">
            <span id="sTitle"></span>
            <span id="sVersion"></span>
          </a>

          <span class="info"
            >&#x24d8;<span id="divDescription" class="infotooltip"></span
          ></span>
        </h2>
      </header>

      <p>
        <button onclick="addMeshes( 1 )">1 mesh</button>
        <button onclick="addMeshes()">100 meshes</button>
      </p>

      <p>
        <button onclick="controls.reset()">reset view</button>
        <button onclick="controls.autoRotate=!controls.autoRotate;">
          rotation
        </button>
      </p>

      <p>
        <output id="outSpeed">50</output>
        <input
          type="range"
          id="inpSpeed"
          onclick="controls.autoRotateSpeed=0.05 * this.value;outSpeed.innerHTML=this.value;"
        />
      </p>

      <p
        title="View the number of objects that need rendering and the total number of triangles used to create the objects"
      >
        <button onclick="setStats()">setStats</button>
      </p>

      <div id="divLog"></div>
    </nav>

    <script>



      let mesh, group, axesHelper, lightDirectional, cameraHelper;
      let renderer, camera, controls, scene;

      init();
      animate();

      function init() {
        camera = new THREE.PerspectiveCamera(
          40,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
        camera.position.set(-100, -100, 100);
        camera.up.set(0, 0, 1);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xcce0ff);
        //scene.fog = new THREE.Fog( 0xcce0ff, 550, 800 );
        scene.add(camera);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.autoRotate = true;
        controls.autoRotateSpeed = 2;
        controls.enableDamping = true;
        controls.enablePan = true;
        controls.dampingFactor = 0.08;
        controls.minDistance = 1;
        controls.maxDistance = 500;

        window.addEventListener("resize", onWindowResize, false);
        window.addEventListener("orientationchange", onWindowResize, false);

        window.addEventListener("keyup", onStart);
        renderer.domElement.addEventListener("click", onStart);
        renderer.domElement.addEventListener("touchstart", onStart);
        renderer.domElement.addEventListener("touchmove", onStart);
        renderer.domElement.addEventListener("touchend", onStart);

        addLights();

        axesHelper = new THREE.AxesHelper(100);
        scene.add(axesHelper);

        //addGround();

        //addMeshes(1);


          for ( let i = 0; i < 1000; i++ ) {
             
            addText( Math.random(), new THREE.Vector3( Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50 ));
          
          }

        //zoomObjectBoundingSphere();
      }


      function addText( text = "Hello world!\n123", position = new THREE.Vector3() ) {

        textMesh = new troika_3d_text.TextMesh();

        scene.add(textMesh);

        // set properties to configure:
        textMesh.text = text;
        textMesh.fontSize = 20;
        textMesh.rotation.x = 0.5 * Math.PI;
        textMesh.position.copy( position )
        textMesh.color = 0xffffff * Math.random()

        // be sure to call sync() after all properties are set to update the rendering:
        //textMesh.sync();

      }


      function addMesh(size = 20) {
        // CylinderGeometry( radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded )
        // SphereGeometry( radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength )
        // TorusGeometry( radius, tube, radialSegments, tubularSegments, arc )

        const geometry = new THREE.BoxGeometry(size, size, size);

        geometry.applyMatrix4(
          new THREE.Matrix4().makeRotationX(-0.5 * Math.PI)
        );
        geometry.applyMatrix4(new THREE.Matrix4().makeScale(1, 1, 1));
        geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0, 0));

        //const material = new THREE.MeshNormalMaterial();
        const material = new THREE.MeshPhongMaterial({
          color: 0xffffff * Math.random(),
          specular: 0xffffff
        });
        mesh = new THREE.Mesh(geometry, material);
        mesh.receiveShadow = true;
        mesh.castShadow = true;
        scene.add(mesh);

        return mesh;
      }

      function addMeshes(count = 100) {
        scene.remove(group);

        group = new THREE.Group();

        for (let i = 0; i < count; i++) {
          group.add(addMesh());
        }

        group.children.forEach(mesh => {
          mesh.position.set(
            Math.random() * 100 - 50,
            Math.random() * 100 - 50,
            Math.random() * 100
          );
          mesh.rotation.set(
            0.2 * Math.random(),
            0.2 * Math.random(),
            0.2 * Math.random()
          );
        });

        scene.add(group);

        zoomObjectBoundingSphere(group);
      }

      function addLights() {
        //scene.add( new THREE.AmbientLight( 0x404040 ) );
        scene.add(new THREE.AmbientLight(0x666666));

        const pointLight = new THREE.PointLight(0xffffff, 0.2);
        pointLight.position.copy(camera.position);
        camera.add(pointLight);

        lightDirectional = new THREE.DirectionalLight(0xdffffff, 0.5);
        lightDirectional.position.set(-50, -200, 100);
        lightDirectional.castShadow = true;
        lightDirectional.shadow.mapSize.width = 1024;
        lightDirectional.shadow.mapSize.height = 1024;

        var d = 100;
        lightDirectional.shadow.camera.left = -d;
        lightDirectional.shadow.camera.right = d;
        lightDirectional.shadow.camera.top = d;
        lightDirectional.shadow.camera.bottom = -d;
        lightDirectional.shadow.camera.far = 500;
        scene.add(lightDirectional);

        scene.add(new THREE.CameraHelper(lightDirectional.shadow.camera));
      }

      function addGround() {
        const geometry = new THREE.PlaneBufferGeometry(2000, 2000);
        const material = new THREE.MeshPhongMaterial({
          color: 0xaaaaaa,
          depthWrite: true,
          side: 2
        });
        const mesh = new THREE.Mesh(geometry, material);
        //mesh.position.z = -50;
        mesh.receiveShadow = true;
        scene.add(mesh);
      }

      function zoomObjectBoundingSphere(obj = group) {
        //console.log( "obj", obj );

        center = new THREE.Vector3(0, 0, 0);
        radius = 50;

        const bbox = new THREE.Box3().setFromObject(obj);
        //console.log( 'bbox', bbox );

        if (bbox.max.x !== Infinity) {
          const sphere = bbox.getBoundingSphere(new THREE.Sphere());

          center = sphere.center;
          radius = sphere.radius;
          //console.log( "sphere", sphere )
        }

        controls.target.copy(center); // needed because model may be far from origin
        controls.maxDistance = 50 * radius;

        delta = camera.position
          .clone()
          .sub(controls.target)
          .normalize();
        //console.log( 'delta', delta );

        position = controls.target
          .clone()
          .add(delta.multiplyScalar(2 * radius));
        //console.log( 'position', position );

        distance = controls.target.distanceTo(camera.position);

        //camera.zoom = distance / (  * radius ) ;

        camera.position.copy(
          center
            .clone()
            .add(new THREE.Vector3(-2 * radius, 2 * radius, 1.0 * radius))
        );
        camera.near = 0.001 * radius; //2 * camera.position.length();
        camera.far = 50 * radius; //2 * camera.position.length();
        camera.updateProjectionMatrix();

        axesHelper.position.copy(center);

        if (lightDirectional) {
          lightDirectional.position.copy(
            center
              .clone()
              .add(new THREE.Vector3(-1.5 * radius, 1.5 * radius, 1.5 * radius))
          );
          lightDirectional.shadow.camera.scale.set(
            0.02 * radius,
            0.02 * radius,
            0.2 * radius
          );

          //targetObject.position.copy( center );

          scene.remove(cameraHelper);
          cameraHelper = new THREE.CameraHelper(lightDirectional.shadow.camera);
          scene.add(cameraHelper);
        }

        let event = new Event("onresetthree", {
          bubbles: true,
          cancelable: false,
          detail: true
        });

        //window.addEventListener( "onrresetthree", doThings, false );

        // listening: or-object-rotation-xx.js
        // listening: dss-display-scene-settings-xx.js

        window.dispatchEvent(event);
      }

      function requestFile(url, callback) {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.onerror = xhr => console.log("error:", xhr);
        //xhr.onprogress = ( xhr ) => console.log( 'bytes loaded:', xhr.loaded );
        xhr.onload = xhr => callback(xhr.target.response);
        xhr.send(null);
      }

      function setStats() {
        const script = document.head.appendChild(
          document.createElement("script")
        );
        script.onload = () => {
          const stats = new Stats();
          const sts = document.body.appendChild(stats.dom);
          sts.style.left = "";
          sts.style.right = "0px";
          requestAnimationFrame(function loop() {
            stats.update();
            requestAnimationFrame(loop);
          });
        };

        script.src =
          "https://raw.githack.com/mrdoob/stats.js/master/build/stats.min.js";

        const render = renderer.info.render;
        if (!window.divRendererInfo)
          divRendererInfo = navMenu.appendChild(document.createElement("div"));
        divRendererInfo.innerHTML = `
	Renderer Info<br>
	Calls: ${render.calls}<br>
	Lines: ${render.lines}<br>
	Triangles: ${render.triangles.toLocaleString()}<br>
	`;
      }

      ////////// Event-driven

      function onStart() {
        controls.autoRotate = false;

        window.removeEventListener("keyup", onStart);
        renderer.domElement.removeEventListener("click", onStart);
        renderer.domElement.removeEventListener("touchstart", onStart);
        renderer.domElement.removeEventListener("touchmove", onStart);
        renderer.domElement.removeEventListener("touchend", onStart);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

        //controls.handleResize();

        //console.log( 'onWindowResize  window.innerWidth', window.innerWidth );
      }

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
        controls.update();
      }
    </script>
  </body>
</html>
