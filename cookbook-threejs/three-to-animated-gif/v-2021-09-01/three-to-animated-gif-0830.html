<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<meta name=description content="Real-time 3D in your browser with menu hiding">
	<meta name=keywords content="Three.js,WebGL,JavaScript,GitHub,FOSS,3D,STEM">
	<meta name="date" content="2021-08-13">
	<title></title>
	<style>
		/* Copyright 2021 Theo Armour. MIT License */

		body {
			font: 100% monospace;
			margin: 0;
		}

		#main {
			border: 1px solid red;
			margin: 0 auto 0 20rem;
			max-width: 40rem;

		}

		.nav {
			background: white;
			border-radius: 10px;
			box-shadow: 0 0 50px -25px black;
			color: gray;
			margin: 1rem;
			width: 16rem;
			overflow: auto;
			padding: 1rem;
			position: absolute;
			resize: both;
		}

		.full-width {
			width: 100%;
		}
	</style>
</head>


<body>

	<nav id=navMenu class=nav>

		<details open>

			<summary>show&darr; || hide&uarr; </summary>

			<h1>
				<a href="https://github.com/pushme-pullyou/tootoo-2021/tree/master/lib3d/" target="_blank"
					title="source code on GitHub"><img
						src=https://pushme-pullyou.github.io/tootoo-2021/lib/assets/icons/mark-github.svg></a>
				<a href="" id=aTitle title="Click this menu title to reset the model"></a>
			</h1>

					<a href="https://github.com/deanm/omggif">omggif</a> example<br /><br />


					<button id="butGenerateGIF">Generate GIF</button>
					<progress id="prgGenerateGIF" value="0" max="1" style="display:none"></progress>
			<div id=divMessage></div>

			<hr>

			<p
				title="View the number of objects that need rendering and the total number of triangles used to create the objects">
				<button onclick="setStats()">View renderer statistics</button>
			</p>

		</details>





	</nav>

	<canvas id="canvas"></canvas>


	<script src="https://cdn.jsdelivr.net/npm/omggif@1.0.10/omggif.min.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r131/build/three.min.js"></script>
	<script>

		aTitle.innerHTML = document.title ? document.title : location.href.split( '/' ).pop().slice( 0, - 5 ).replace( /-/g, ' ' );

		function generateGIF( element, renderFunction, duration = 1, fps = 30 ) {

			const frames = duration * fps;

			const canvas = document.createElement( 'canvas' );
			canvas.width = element.width;
			canvas.height = element.height;

			const context = canvas.getContext( '2d' );

			const buffer = new Uint8Array( canvas.width * canvas.height * frames * 5 );
			const pixels = new Uint8Array( canvas.width * canvas.height );
			const writer = new GifWriter( buffer, canvas.width, canvas.height, { loop: 0 } );

			let current = 0;

			return new Promise( async function addFrame( resolve ) {

				renderFunction( current / frames );

				context.drawImage( element, 0, 0 );

				const data = context.getImageData( 0, 0, canvas.width, canvas.height ).data;

				const palette = [];

				for ( var j = 0, k = 0, jl = data.length; j < jl; j += 4, k++ ) {

					const r = Math.floor( data[ j + 0 ] * 0.1 ) * 10;
					const g = Math.floor( data[ j + 1 ] * 0.1 ) * 10;
					const b = Math.floor( data[ j + 2 ] * 0.1 ) * 10;
					const color = r << 16 | g << 8 | b << 0;

					const index = palette.indexOf( color );

					if ( index === -1 ) {

						pixels[ k ] = palette.length;
						palette.push( color );

					} else {

						pixels[ k ] = index;

					}

				}

				// Force palette to be power of 2

				let powof2 = 1;
				while ( powof2 < palette.length ) powof2 <<= 1;
				palette.length = powof2;


				const delay = 100 / fps; // Delay in hundredths of a sec (100 = 1s)
				const options = { palette: new Uint32Array( palette ), delay: delay };
				writer.addFrame( 0, 0, canvas.width, canvas.height, pixels, options );

				current++;

				progress.value = current / frames;

				if ( current < frames ) {

					await setTimeout( addFrame, 0, resolve );

				} else {

					resolve( buffer.subarray( 0, writer.end() ) );

				}

			} );

		}

		//

		butGenerateGIF.addEventListener( 'click', async function () {

			butGenerateGIF.style.display = 'none';
			prgGenerateGIF.style.display = '';

			// Generate

			const buffer = await generateGIF( canvas, render, 4, 30 );

			butGenerateGIF.style.display = '';
			prgGenerateGIF.style.display = 'none';

			// Download

			const blob = new Blob( [ buffer ], { type: 'image/gif' } );

			const link = document.createElement( 'a' );
			link.href = URL.createObjectURL( blob );
			link.download = 'animation.gif';
			link.dispatchEvent( new MouseEvent( 'click' ) );

		} );

		// Animation

		const camera = new THREE.PerspectiveCamera( 50, 1, 0.1, 10 );
		camera.position.z = 2;

		const scene = new THREE.Scene();

		const geometry = new THREE.IcosahedronGeometry( 0.75, 1 );
		const material = new THREE.MeshNormalMaterial( { flatShading: true } );
		const mesh = new THREE.Mesh( geometry, material );
		scene.add( mesh );

		const renderer = new THREE.WebGLRenderer( { canvas: canvas } );
		renderer.setClearColor( 0xffffff, 1 );
		renderer.setSize( 500, 500 );

		//

		function render( progress ) {

			// progress goes from 0 to 1

			mesh.rotation.x = progress * Math.PI * 2;
			mesh.rotation.y = - progress * Math.PI * 2;

			renderer.render( scene, camera );

		}

		function animation( time ) {

			if ( prgGenerateGIF.style.display === 'none' ) {

				// Only render when not generating

				render( ( time / 5000 ) % 1 );

			}

			requestAnimationFrame( animation );

		}

		requestAnimationFrame( animation );

	</script>
</body>

</html>