<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no,minimum-scale=1.0,maximum-scale=1.0">
	<meta name=description content="Real-time 3D in your browser with menu hiding">
	<meta name=keywords content="Three.js,WebGL,JavaScript,GitHub,FOSS,3D,STEM">
	<meta name="date" content="2021-08-13">
	<title></title>
	<style>
		/* Copyright 2021 Theo Armour. MIT License */

		body {
			font: 100% monospace;
			margin: 0;
		}

		#main {
			border: 1px solid red;
			margin: 0 auto 0 20rem;
			max-width: 40rem;

		}

		.nav {
			background: white;
			border-radius: 10px;
			box-shadow: 0 0 50px -25px black;
			color: gray;
			margin: 1rem;
			width: 20rem;
			overflow: auto;
			padding: 0.2rem;
			position: absolute;
			resize: both;
		}

		.full-width {
			width: 100%;
		}
	</style>
</head>

<body>
	<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r131/build/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r131/examples/js/controls/OrbitControls.js"></script>


	<nav id=navMenu class=nav>

		<details open>

			<summary>show&darr; || hide&uarr; </summary>

			<h1>
				<a href="https://github.com/pushme-pullyou/tootoo-2021/tree/master/lib3d/" target="_blank"
					title="source code on GitHub"><img
						src=https://pushme-pullyou.github.io/tootoo-2021/lib/assets/icons/mark-github.svg></a>
				<a href="" id=aTitle title="Click this menu title to reset the model"></a>
			</h1>
			<div>For Aggie & Yvonne</div>
			<div id=divMessage></div>

		</details>

	</nav>


	<script>

		let renderer, camera, controls, scene;
		let geometry, material, mesh, axesHelper;

		init();
		animate();

		function init() {

			//aTitle.innerHTML = document.title = location.href.split( "/" ).pop();

			aTitle.innerHTML = document.title ? document.title : location.href.split( '/' ).pop().slice( 0, - 5 ).replace( /-/g, ' ' );

			const fov = 40;
			const aspect = window.innerWidth / window.innerHeight;
			const near = 1;
			const far = 1000;
			camera = new THREE.PerspectiveCamera( fov, aspect, near, far );
			camera.position.set( -100, -100, 100 );
			camera.up.set( 0, 0, 1 );

			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xcce0ff );
			//scene.fog = new THREE.Fog( 0xcce0ff, 550, 800 );
			scene.add( camera );

			renderer = new THREE.WebGLRenderer( { antialias: true, alpha: false } );
			//renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;

			controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.autoRotate = true;
			controls.autoRotateSpeed = 2;
			controls.enableDamping = true;
			controls.enablePan = true;
			controls.dampingFactor = 0.08;
			controls.minDistance = 1;
			controls.maxDistance = 500;

			window.addEventListener( 'resize', onWindowResize, false );
			window.addEventListener( 'orientationchange', onWindowResize, false );
			window.addEventListener( 'keyup', function () { controls.autoRotate = false; }, false );
			renderer.domElement.addEventListener( 'click', function () { controls.autoRotate = false; }, false );

			axesHelper = new THREE.AxesHelper( 50 );
			//scene.add( axesHelper );

			addLights()

			material = new THREE.MeshPhongMaterial( { color: 0x222222 });

			ball1 = getBallAndChain();

			ball2 = getBallAndChain();

			ball2.rotation.z = 1
			ball2.position.set( 80, 10, 0 );

			shackles1 = getShackles();

			shackles2 = getShackles();
			shackles2.rotation.x = 1.4
			shackles2.rotation.z = -0.2
			shackles2.position.set( 35, -20, -8 );

			link9 = getLink( -1, -3, -3.5, scene );
			link9.position.set( 61, -25, -17 );

		}


		function addLights () {

				//scene.add( new THREE.AmbientLight( 0x404040 ) );
				scene.add( new THREE.AmbientLight( 0x888888 ) );

				const pointLight = new THREE.PointLight( 0xffffff, 0.2 );
				pointLight.position.copy( camera.position );
				pointLight.shadow.radius = 2;
				//pointLight.castShadow = true;
				camera.add( pointLight );

				lightDirectional = new THREE.DirectionalLight( 0xdffffff, 0.5 );
				lightDirectional.position.set( -0, -200, 100 );
				lightDirectional.castShadow = true;
				// lightDirectional.shadow.mapSize.width = 1024;
				// lightDirectional.shadow.mapSize.height = 1024;

				let d = 100;
				lightDirectional.shadow.camera.left = -d;
				lightDirectional.shadow.camera.right = d;
				lightDirectional.shadow.camera.top = d;
				lightDirectional.shadow.camera.bottom = -d;
				lightDirectional.shadow.camera.far = 500;
				scene.add( lightDirectional );

				lightDirectional = lightDirectional;
			};

		function getBallAndChain() {

			//material = new THREE.MeshNormalMaterial();

			geometry = new THREE.SphereGeometry( 25 );
			ball = new THREE.Mesh( geometry, material );
			ball.rotation.z = -0.3;
			ball.position.z = 2;
			ball.castShadow = ball.receiveShadow = true;
			scene.add( ball );

			geometry = new THREE.CylinderGeometry( 8, 8, 8, 24 );
			geometry.translate( 0, -25, 0 );
			base = new THREE.Mesh( geometry, material );
			base.castShadow = base.receiveShadow = true;

			ball.add( base );

			geometry = new THREE.TorusGeometry( 6, 1.5, 12, 24 );
			geometry.translate( 0, -30, 0 );
			ring = new THREE.Mesh( geometry, material );
			base.add( ring );
			addGround();

			link1 = getLink();
			link1.position.set( 0, -38.5, -3.5 );
			link1.rotation.set( 1, 1.5, 0 );

			link2 = getLink( 1.5 );
			link2.position.set( 0, -40, -16 );

			link3 = getLink( 0, 0.5, 1.2 );
			link3.position.set( -8, -40, -20 );

			link4 = getLink( 0 );
			link4.position.set( -14, -40, -20 );

			link5 = getLink( 0.5, 1.5, -2 );
			link5.position.set( -19, -39, -20 );

			link6 = getLink( 0, 0, 1 );
			link6.position.set( -27, -30, -20 );

			link7 = getLink( 0, 1.2, 0 );
			link7.position.set( -30, -20, -20 );

			link8 = getLink( 0, 0, 1.2 );
			link8.position.set( -34, -10, -20 );

			return ball;


		}


		function getShackles() {

			shackles = getShackle();
			shackles.position.set( -65, 6, -25 );
			scene.add( shackles );

			shackle2 = getShackle();
			shackle2.scale.y = -1;
			shackle2.rotation.z = 0.3;
			shackle2.position.set( 1.5, -10, 0 );
			shackles.add( shackle2 );

			return shackles;

		}

		function getShackle() {

			path = new THREE.Path();

			path.moveTo( 10, 0 )
			//path.lineTo( 5, -5 );
			path.absarc( 5, 0, 5, 0, Math.PI );
			path.lineTo( -1.5, 0 );
			path.lineTo( -1.5, -1 );
			path.lineTo( 1, -1 );
			path.lineTo( 1, 0 );
			path.absarc( 5, 0, 4, Math.PI, 0, true );
			path.lineTo( 9, 0 );
			path.lineTo( 9, -2 );
			path.lineTo( 12, -2 );
			path.absarc( 12, -1, 1, -1.5, 1.5 );

			const points = path.getPoints(); //.map( point => new THREE.Vector3( point.x, point.y, 0 ) );
			//console.log( "points", points );


			shape = new THREE.Shape( points );

			geometry = new THREE.ExtrudeGeometry( shape, { bevelEnabled: false, depth: 5 } );
			geometry.scale( 2, 2, 2 )

			//material = new THREE.MeshNormalMaterial();
			shackle = new THREE.Mesh( geometry, material );
			shackle.castShadow = shackle.receiveShadow = true;

			return shackle;

		}



		function getLink( rotX = 0, rotY = 0, rotZ = 0, parent = ball ) {

			path = new THREE.Path();

			path.moveTo( 5, -5 )
			path.lineTo( 5, -5 );
			path.absarc( 0, 5, 5, 0, Math.PI );
			path.lineTo( -5, -5 );
			path.absarc( 0, -5, 5, Math.PI, 0 );

			const points = path.getPoints().map( point => new THREE.Vector3( point.x, point.y, 0 ) );
			//console.log( "points", points );

			curve = new THREE.CatmullRomCurve3( [
				new THREE.Vector3( 0, - 40, - 40 ),
				new THREE.Vector3( 0, 40, - 40 ),
				new THREE.Vector3( 0, 140, - 40 ),
				new THREE.Vector3( 0, 40, 40 ),
				new THREE.Vector3( 0, - 40, 40 )
			] );

			curve = new THREE.CatmullRomCurve3( [
				new THREE.Vector3( -10, 0, 0 ),
				new THREE.Vector3( 0, 10, 0 ),
				new THREE.Vector3( 10, 0, 0 ),

			] );

			curve = new THREE.CatmullRomCurve3( points )

			const geometry = new THREE.TubeGeometry( curve, 20, 2, 12, true );
			geometry.scale( 0.75, 0.75, 0.75 );
			//geometry.rotateZ( rotZ );
			geometry.rotateX( rotX );
			geometry.rotateY( rotY );
			geometry.rotateZ( rotZ );
			//const material = new THREE.MeshNormalMaterial();
			const link = new THREE.Mesh( geometry, material );
			link.castShadow = link.receiveShadow = true;
			//mesh.position.z = 30
			parent.add( link );

			return link;

			// const geometry = new THREE.BufferGeometry().setFromPoints( points );
			// geometry.translate( 0, 0, 30)
			// const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
			// const line = new THREE.Line( geometry, material );
			// scene.add( line );

		}


		function addGround( position = new THREE.Vector3( 0, 0, -25 ) ) {

			const geometry = new THREE.PlaneBufferGeometry( 5000, 5000 );
			geometry.translate( position.x, position.y, position.z );

			const material = new THREE.MeshStandardMaterial( { color: 0xffffff, side: 0 } );
			ground = new THREE.Mesh( geometry, material );
			ground.name = "ground";
			ground.receiveShadow = true;
			scene.add( ground );

		};

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

			//console.log( 'onWindowResize  window.innerWidth', window.innerWidth );

		}


		function animate() {

			requestAnimationFrame( animate );
			renderer.render( scene, camera );
			controls.update();

		}

	</script>

</body>

</html>